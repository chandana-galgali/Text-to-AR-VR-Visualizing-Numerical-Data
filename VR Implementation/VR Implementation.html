<html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Data Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            max-width: 300px;
            z-index: 100;
        }
        #json-input {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            width: 300px;
        }
        textarea {
            width: 100%;
            height: 150px;
            margin-bottom: 10px;
            background-color: rgba(255,255,255,0.9);
            border-radius: 3px;
            padding: 5px;
            font-family: monospace;
        }
        button {
            padding: 8px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        button:hover {
            background-color: #3e8e41;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info">
        <h2>3D Data Visualization</h2>
        <p>Controls: 
            <br>- Rotate: Left-click + drag
            <br>- Pan: Right-click + drag
            <br>- Zoom: Scroll wheel
        </p>
        <div id="hover-info"></div>
    </div>
    
    <div id="json-input">
        <h3>Enter JSON Data</h3>
        <textarea id="data-input">{
  "Programming Language Survey Results": {
    "Python": 35,
    "Java": 25,
    "C++": 20,
    "JavaScript": 10
  }
}</textarea>
        <button id="visualize-btn">Visualize Data</button>
    </div>

    <!-- Import Three.js and OrbitControls -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    
    <script>
        // Main application code
        document.addEventListener('DOMContentLoaded', () => {
            // DOM elements
            const container = document.getElementById('container');
            const dataInput = document.getElementById('data-input');
            const visualizeBtn = document.getElementById('visualize-btn');
            const hoverInfo = document.getElementById('hover-info');
            
            // Three.js objects
            let scene, camera, renderer, controls, raycaster, mouse;
            
            // Chart objects
            let chartGroup = null;
            let chartObjects = [];
            let labels = [];
            
            // Initialize Three.js scene
            function initScene() {
                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x2a3b4c);
                
                // Create camera
                camera = new THREE.PerspectiveCamera(
                    60, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                camera.position.set(0, 40, 100);
                camera.lookAt(0, 0, 0);
                
                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);
                
                // Create orbit controls for interaction
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.screenSpacePanning = false;
                controls.maxPolarAngle = Math.PI / 2;
                
                // Create raycaster for interactivity
                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();
                
                // Create lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(20, 40, 20);
                scene.add(directionalLight);
                
                // Add grid helper
                const gridHelper = new THREE.GridHelper(100, 20);
                scene.add(gridHelper);
                
                // Add chart group
                chartGroup = new THREE.Group();
                scene.add(chartGroup);
                
                // Add event listeners
                window.addEventListener('resize', onWindowResize);
                window.addEventListener('mousemove', onMouseMove);
                
                // Start animation loop
                animate();
            }
            
            // Create 3D bar chart from data
            function createBarChart(data) {
                // Clear previous chart
                clearChart();
                
                // Extract data
                const categoryName = Object.keys(data)[0];
                const categoryData = data[categoryName];
                
                if (!categoryData || typeof categoryData !== 'object') {
                    console.error('Invalid data format');
                    return;
                }
                
                // Create title text
                createTextSprite(categoryName, 0, 50, 0, 10);
                
                // Extract labels and values
                const dataLabels = Object.keys(categoryData);
                const dataValues = dataLabels.map(label => categoryData[label]);
                
                // Calculate dimensions
                const maxValue = Math.max(...dataValues);
                const barWidth = 8;
                const spacing = 4;
                const barDepth = 8;
                const heightScale = 40 / maxValue;
                
                // Calculate total width
                const totalWidth = (barWidth + spacing) * dataValues.length;
                const startX = -totalWidth / 2 + barWidth / 2;
                
                // Colors for bars
                const colors = [
                    0x3498db, 0xe74c3c, 0x2ecc71, 0xf39c12, 0x9b59b6,
                    0x1abc9c, 0xd35400, 0x34495e, 0x16a085, 0xc0392b
                ];
                
                // Create bars
                for (let i = 0; i < dataValues.length; i++) {
                    const value = dataValues[i];
                    const label = dataLabels[i];
                    const height = value * heightScale;
                    const x = startX + i * (barWidth + spacing);
                    
                    // Create bar geometry
                    const geometry = new THREE.BoxGeometry(barWidth, height, barDepth);
                    
                    // Create material with phong shading for better look
                    const material = new THREE.MeshPhongMaterial({
                        color: colors[i % colors.length],
                        shininess: 60
                    });
                    
                    // Create mesh
                    const bar = new THREE.Mesh(geometry, material);
                    bar.position.set(x, height / 2, 0);
                    
                    // Store data with the bar for interactivity
                    bar.userData = {
                        label: label,
                        value: value
                    };
                    
                    // Add to chart group
                    chartGroup.add(bar);
                    chartObjects.push(bar);
                    
                    // Create value label
                    createTextSprite(value.toString(), x, height + 3, 0, 3);
                    
                    // Create category label
                    const labelSprite = createTextSprite(label, x, -2, 0, 3);
                    labels.push(labelSprite);
                }
                
                // Position camera for good initial view
                camera.position.set(0, maxValue * heightScale / 2, totalWidth * 1.5);
                controls.target.set(0, maxValue * heightScale / 4, 0);
                controls.update();
            }
            
            // Create text sprite for labels
            function createTextSprite(text, x, y, z, size = 5) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 128;
                
                // Draw background
                context.fillStyle = 'rgba(50, 50, 50, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw text
                context.font = 'Bold 24px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                // Create sprite
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                
                // Position and scale
                sprite.position.set(x, y, z);
                sprite.scale.set(size, size / 2, 1);
                
                // Add to chart group
                chartGroup.add(sprite);
                
                return sprite;
            }
            
            // Clear previous chart
            function clearChart() {
                if (chartGroup) {
                    // Remove all children from chart group
                    while (chartGroup.children.length > 0) {
                        const object = chartGroup.children[0];
                        
                        // Dispose of geometries and materials
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(material => material.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                        
                        chartGroup.remove(object);
                    }
                }
                
                // Clear arrays
                chartObjects = [];
                labels = [];
            }
            
            // Handle window resize
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            
            // Handle mouse movement for interactive hover
            function onMouseMove(event) {
                // Calculate mouse position in normalized device coordinates
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            }
            
            // Check for intersections with bars
            function checkIntersections() {
                // Update the picking ray with the camera and mouse position
                raycaster.setFromCamera(mouse, camera);
                
                // Calculate objects intersecting the picking ray
                const intersects = raycaster.intersectObjects(chartObjects);
                
                // Reset all bar colors
                chartObjects.forEach(bar => {
                    bar.material.emissive.setHex(0x000000);
                });
                
                // Show hover info
                if (intersects.length > 0) {
                    // Highlight intersected object
                    intersects[0].object.material.emissive.setHex(0x333333);
                    
                    // Get data
                    const userData = intersects[0].object.userData;
                    
                    // Update hover info
                    hoverInfo.innerHTML = `
                        <h3>${userData.label}</h3>
                        <p>Value: ${userData.value}</p>
                    `;
                } else {
                    // Clear hover info
                    hoverInfo.innerHTML = '';
                }
            }
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Update controls
                controls.update();
                
                // Check for intersections
                if (chartObjects.length > 0) {
                    checkIntersections();
                }
                
                // Make labels always face the camera
                labels.forEach(label => {
                    label.lookAt(camera.position);
                });
                
                // Render scene
                renderer.render(scene, camera);
            }
            
            // Handle visualize button click
            visualizeBtn.addEventListener('click', () => {
                try {
                    // Parse JSON input
                    const data = JSON.parse(dataInput.value);
                    
                    // Create chart
                    createBarChart(data);
                } catch (error) {
                    console.error('Error parsing JSON:', error);
                    alert('Invalid JSON format. Please check your input.');
                }
            });
            
            // Initialize the scene
            initScene();
            
            // Create default chart from initial data
            try {
                const defaultData = JSON.parse(dataInput.value);
                createBarChart(defaultData);
            } catch (error) {
                console.error('Error parsing default JSON:', error);
            }
        });
    </script>
</body>
</html>
